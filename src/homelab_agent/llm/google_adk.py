"""Google ADK LLM provider implementation.

Generated by Copilot.
"""

import logging
import os
from pathlib import Path
from typing import Any, Awaitable, Callable, Optional, Sequence

from homelab_agent.llm.base import (
    BaseLLMProvider,
    LLMAuthenticationError,
    LLMConfigurationError,
    LLMError,
    LLMResponse,
    Message,
)
from homelab_agent.constants import DEFAULT_SYSTEM_PROMPT

logger = logging.getLogger(__name__)


class GoogleADKProvider(BaseLLMProvider):
    """Google ADK LLM provider.
    
    Uses the Google Agent Development Kit with DatabaseSessionService
    for persistent SQLite sessions.
    """

    def __init__(
        self,
        api_key: str,
        model: str = "gemini-2.5-pro-preview-05-06",
        database_path: Optional[Path] = None,
        app_name: str = "homelab-agent",
        tools: Optional[Sequence[Callable[..., Any]]] = None,
    ) -> None:
        """Initialize the Google ADK provider.
        
        Args:
            api_key: Google AI API key.
            model: Model to use.
            database_path: Path to SQLite database for sessions.
            app_name: Application name for sessions.
            tools: Optional list of tool functions to provide to the agent.
            
        Raises:
            LLMConfigurationError: If API key is not provided.
        """
        if not api_key:
            raise LLMConfigurationError("Google API key is required")

        self._api_key = api_key
        self._model = model
        self._database_path = database_path
        self._app_name = app_name
        self._tools: list[Any] = list(tools) if tools else []
        
        # Set API key in environment for ADK
        os.environ["GOOGLE_API_KEY"] = api_key
        
        # Lazy-loaded components
        self._agent = None
        self._session_service = None
        self._runner = None
        
        # Session cache: user_id -> session_id (prevents creating duplicate sessions)
        self._session_cache: dict[str, str] = {}
        
        # Tool call notification callback
        # Signature: async (tool_name: str, args: dict, result: Any | None) -> None
        self._tool_callback: Optional[Callable[[str, dict, Any], Awaitable[None]]] = None

    def _get_session_service(self):
        """Get or create the session service."""
        if self._session_service is None:
            try:
                if self._database_path:
                    from google.adk.sessions import DatabaseSessionService
                    
                    # Ensure directory exists
                    self._database_path.parent.mkdir(parents=True, exist_ok=True)
                    # Use aiosqlite for async SQLite support
                    db_url = f"sqlite+aiosqlite:///{self._database_path}"
                    self._session_service = DatabaseSessionService(db_url=db_url)
                    logger.info(f"Using SQLite session storage: {self._database_path}")
                else:
                    from google.adk.sessions import InMemorySessionService
                    
                    self._session_service = InMemorySessionService()
                    logger.info("Using in-memory session storage")
                    
            except ImportError as e:
                raise LLMConfigurationError(
                    f"google-adk package is not installed properly: {e}"
                )
        return self._session_service

    def _get_agent(self):
        """Get or create the ADK agent."""
        if self._agent is None:
            try:
                from google.adk.agents import Agent
                
                self._agent = Agent(
                    model=self._model,
                    name="hal",
                    description="Homelab assistant that helps manage infrastructure",
                    instruction=DEFAULT_SYSTEM_PROMPT,
                    tools=self._tools if self._tools else None,  # type: ignore
                )
                if self._tools:
                    logger.info(f"Created ADK agent with model: {self._model} and {len(self._tools)} tools")
                else:
                    logger.info(f"Created ADK agent with model: {self._model}")
                
            except ImportError as e:
                raise LLMConfigurationError(
                    f"google-adk package is not installed properly: {e}"
                )
        return self._agent

    def _get_runner(self):
        """Get or create the ADK runner."""
        if self._runner is None:
            try:
                from google.adk.runners import Runner
                
                self._runner = Runner(
                    agent=self._get_agent(),
                    app_name=self._app_name,
                    session_service=self._get_session_service(),
                )
                logger.info("Created ADK runner")
                
            except ImportError as e:
                raise LLMConfigurationError(
                    f"google-adk package is not installed properly: {e}"
                )
        return self._runner

    @property
    def name(self) -> str:
        """Get the provider name."""
        return "google"

    @property
    def model(self) -> str:
        """Get the current model."""
        return self._model

    def set_tool_callback(
        self,
        callback: Optional[Callable[[str, dict, Any], Awaitable[None]]],
    ) -> None:
        """Set the callback for tool call notifications.
        
        The callback is called whenever a tool is invoked, with:
        - tool_name: The name of the tool being called
        - args: The arguments passed to the tool
        - result: The result of the tool call (None if this is a pre-call notification)
        
        Args:
            callback: Async callback function or None to disable.
        """
        self._tool_callback = callback

    async def get_or_create_session(self, user_id: str) -> str:
        """Get existing session or create a new one for a user.
        
        Uses an in-memory cache to prevent creating duplicate sessions.
        
        Args:
            user_id: The user identifier.
            
        Returns:
            The session ID.
        """
        # Check cache first
        if user_id in self._session_cache:
            logger.debug(f"Using cached session for {user_id}: {self._session_cache[user_id]}")
            return self._session_cache[user_id]
        
        session_service = self._get_session_service()
        
        # Try to find existing session for this user
        try:
            response = await session_service.list_sessions(
                app_name=self._app_name,
                user_id=user_id,
            )
            if response.sessions and len(response.sessions) > 0:
                # Sort by last_update_time to get the most recent session
                # The ADK returns sessions but order is not guaranteed
                sessions = sorted(
                    response.sessions,
                    key=lambda s: s.last_update_time or s.create_time or "",
                    reverse=True,
                )
                session_id = sessions[0].id
                self._session_cache[user_id] = session_id
                logger.info(f"Found existing session for {user_id}: {session_id} (out of {len(sessions)} sessions)")
                return session_id
        except Exception as e:
            logger.warning(f"Error finding existing session for {user_id}: {e}")
        
        # Create new session
        session = await session_service.create_session(
            app_name=self._app_name,
            user_id=user_id,
        )
        self._session_cache[user_id] = session.id
        logger.info(f"Created new session for user {user_id}: {session.id}")
        return session.id

    async def forget_session(self, user_id: str) -> bool:
        """Delete all sessions for a user (forget command).
        
        Args:
            user_id: The user identifier.
            
        Returns:
            True if sessions were deleted, False otherwise.
        """
        session_service = self._get_session_service()
        
        # Clear cache first
        if user_id in self._session_cache:
            del self._session_cache[user_id]
        
        try:
            response = await session_service.list_sessions(
                app_name=self._app_name,
                user_id=user_id,
            )
            
            deleted = False
            if response.sessions:
                for session in response.sessions:
                    await session_service.delete_session(
                        app_name=self._app_name,
                        user_id=user_id,
                        session_id=session.id,
                    )
                    deleted = True
                    logger.info(f"Deleted session {session.id} for user {user_id}")
            
            return deleted
            
        except Exception as e:
            logger.error(f"Failed to delete sessions for {user_id}: {e}")
            return False

    async def generate(
        self,
        prompt: str,
        system_prompt: Optional[str] = None,
        temperature: float = 0.7,
        max_tokens: Optional[int] = None,
    ) -> LLMResponse:
        """Generate a response from a single prompt (stateless)."""
        messages = []
        if system_prompt:
            messages.append(Message(role="system", content=system_prompt))
        messages.append(Message(role="user", content=prompt))
        return await self.chat(messages, temperature, max_tokens)

    async def chat(
        self,
        messages: list[Message],
        temperature: float = 0.7,
        max_tokens: Optional[int] = None,
    ) -> LLMResponse:
        """Generate a response from a conversation (stateless, no session)."""
        try:
            from google.adk.agents import Agent
            from google.adk.runners import Runner
            from google.adk.sessions import InMemorySessionService
            from google.genai import types
            
            # For stateless chat, use in-memory session
            temp_service = InMemorySessionService()
            
            # Extract system prompt if present
            system_prompt = DEFAULT_SYSTEM_PROMPT
            user_messages = []
            for msg in messages:
                if msg.role == "system":
                    system_prompt = msg.content
                else:
                    user_messages.append(msg)
            
            # Create temporary agent
            agent = Agent(
                model=self._model,
                name="hal_temp",
                instruction=system_prompt,
            )
            
            runner = Runner(
                agent=agent,
                app_name="temp",
                session_service=temp_service,
            )
            
            # Create temp session
            session = await temp_service.create_session(
                app_name="temp",
                user_id="temp",
            )
            
            # Run conversation
            content = ""
            for msg in user_messages:
                user_content = types.Content(
                    role="user",
                    parts=[types.Part.from_text(text=msg.content)],
                )
                
                async for event in runner.run_async(
                    user_id="temp",
                    session_id=session.id,
                    new_message=user_content,
                ):
                    if hasattr(event, "content") and event.content:
                        if hasattr(event.content, "parts") and event.content.parts:
                            for part in event.content.parts:
                                if hasattr(part, "text") and part.text:
                                    content = part.text
            
            return LLMResponse(
                content=content,
                model=self._model,
                usage={},
            )

        except Exception as e:
            logger.exception(f"Google ADK error: {e}")
            raise LLMError(f"Google ADK generation failed: {e}")

    async def chat_with_session(
        self,
        user_id: str,
        message: str,
    ) -> str:
        """Chat with persistent session.
        
        This is the main method for conversational use with memory.
        Captures tool calls and emits notifications via the callback.
        
        Args:
            user_id: The user identifier.
            message: The user's message.
            
        Returns:
            The assistant's response.
        """
        try:
            from google.genai import types
            
            runner = self._get_runner()
            session_id = await self.get_or_create_session(user_id)
            
            user_content = types.Content(
                role="user",
                parts=[types.Part.from_text(text=message)],
            )
            
            response_content = ""
            async for event in runner.run_async(
                user_id=user_id,
                session_id=session_id,
                new_message=user_content,
            ):
                # Check for tool calls (function calls)
                if self._tool_callback and hasattr(event, "get_function_calls"):
                    function_calls = event.get_function_calls()
                    if function_calls:
                        for call in function_calls:
                            tool_name = call.name if hasattr(call, "name") else str(call)
                            tool_args = call.args if hasattr(call, "args") else {}
                            try:
                                # Notify about tool call (pre-execution)
                                await self._tool_callback(tool_name, dict(tool_args) if tool_args else {}, None)
                            except Exception as cb_err:
                                logger.warning(f"Tool callback error: {cb_err}")
                
                # Check for tool results (function responses)
                if self._tool_callback and hasattr(event, "get_function_responses"):
                    function_responses = event.get_function_responses()
                    if function_responses:
                        for response in function_responses:
                            tool_name = response.name if hasattr(response, "name") else "unknown"
                            tool_result = response.response if hasattr(response, "response") else None
                            try:
                                # Notify about tool result
                                await self._tool_callback(tool_name, {}, tool_result)
                            except Exception as cb_err:
                                logger.warning(f"Tool callback error: {cb_err}")
                
                # Extract text content for final response
                if hasattr(event, "content") and event.content:
                    if hasattr(event.content, "parts") and event.content.parts:
                        for part in event.content.parts:
                            if hasattr(part, "text") and part.text:
                                response_content = part.text
            
            return response_content

        except Exception as e:
            error_msg = str(e).lower()
            if "api key" in error_msg or "authentication" in error_msg:
                raise LLMAuthenticationError(f"Google API authentication failed: {e}")
            logger.exception(f"Google ADK error: {e}")
            raise LLMError(f"Google ADK generation failed: {e}")

    async def health_check(self) -> bool:
        """Check if the provider is healthy."""
        try:
            response = await self.generate("Say 'ok'", max_tokens=10)
            return bool(response.content)
        except Exception as e:
            logger.warning(f"Google ADK health check failed: {e}")
            return False
