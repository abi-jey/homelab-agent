"""Main agent entry point for the homelab agent service."""

import asyncio
import signal
import sys
from datetime import datetime
from pathlib import Path
from typing import Any, Optional

import uvicorn

from homelab_agent.api.server import AgentAPIServer
from homelab_agent.channels import (
    BaseCommunicationChannel,
    IncomingMessage,
    OutgoingMessage,
    create_channel,
)
from homelab_agent.channels.telegram import TelegramChannel
from homelab_agent.config import Config
from homelab_agent.llm import BaseLLMProvider, LLMResponse, create_llm_provider
from homelab_agent.llm.base import LLMError, Message
from homelab_agent.llm.google_adk import GoogleADKProvider
from homelab_agent.tools.scheduler import (
    WakeUpScheduler,
    set_wake_up_context,
    wake_up_in,
)
from homelab_agent.tools.instructions import (
    InstructionManager,
    get_my_instructions,
    reset_my_instructions,
    set_instruction_context,
    update_my_instructions,
)
from homelab_agent.tools.shell import run_shell_command, run_shell_script
from homelab_agent.tools.files import (
    read_file as file_read,
    write_file as file_write,
    list_directory,
    delete_file,
    file_info,
    apply_patch,
)
from homelab_agent.tools.clones import (
    list_clones,
    create_clone,
    start_clone,
    stop_clone,
    delete_clone,
    get_clone_logs,
)
from homelab_agent.tools.reasoning import (
    share_reasoning,
    set_reasoning_context,
    clear_reasoning_context,
)
from homelab_agent.webui import WebUI
from homelab_agent.constants import DEFAULT_SYSTEM_PROMPT
from homelab_agent.logging import setup_logging, get_logger
from homelab_agent.utils.tool_logger import ToolCallLogger

# Configure Rich logging
setup_logging()
logger = get_logger(__name__)

# Current tool notification context (per-request)
_tool_notification_context: dict[str, Any] = {}


class HomelabAgent:
    """Main agent class that runs the homelab agent service."""

    def __init__(
        self,
        config: Config,
        system_prompt: Optional[str] = None,
    ) -> None:
        """Initialize the agent.
        
        Args:
            config: Configuration for the agent.
            system_prompt: Optional custom system prompt.
        """
        self.config = config
        self.system_prompt = system_prompt or DEFAULT_SYSTEM_PROMPT
        
        self._running = False
        self._shutdown_event: Optional[asyncio.Event] = None
        
        # Core components
        self._llm_provider: Optional[BaseLLMProvider] = None
        self._channel: Optional[BaseCommunicationChannel] = None
        self._api_server: Optional[AgentAPIServer] = None
        
        # Wake-up scheduler
        self._scheduler = WakeUpScheduler(
            data_path=config.runtime_dir / "data" / "wakeups.json"
        )
        
        # Instruction manager
        self._instruction_manager = InstructionManager(
            data_path=config.runtime_dir / "data" / "instructions.json",
            default_instruction=self.system_prompt,
        )
        
        # Background task for checking scheduled wake-ups
        self._wakeup_task: Optional[asyncio.Task] = None
        
        # Web UI
        self._webui: Optional[WebUI] = None
        self._webui_server_task: Optional[asyncio.Task] = None
        
        # Tool call logger (JSON file logging)
        # Generated by Copilot
        logs_dir = config.runtime_dir / "logs"
        logs_dir.mkdir(parents=True, exist_ok=True)
        self._tool_logger = ToolCallLogger(
            log_path=logs_dir / "tool_calls.json"
        )
        
        # Conversation history per user (for non-ADK providers)
        self._conversations: dict[str, list[Message]] = {}

    @property
    def llm_provider(self) -> Optional[BaseLLMProvider]:
        """Get the LLM provider."""
        return self._llm_provider

    @property
    def channel(self) -> Optional[BaseCommunicationChannel]:
        """Get the communication channel."""
        return self._channel

    @property
    def api_server(self) -> Optional[AgentAPIServer]:
        """Get the HTTP API server."""
        return self._api_server

    def _get_or_create_conversation(self, user_id: str) -> list[Message]:
        """Get or create a conversation history for a user."""
        if user_id not in self._conversations:
            self._conversations[user_id] = [
                Message(role="system", content=self.system_prompt)
            ]
        return self._conversations[user_id]

    def clear_conversation(self, user_id: str) -> None:
        """Clear the conversation history for a user."""
        if user_id in self._conversations:
            del self._conversations[user_id]

    async def _handle_forget(self, user_id: str) -> bool:
        """Handle forget command - clear session for a user.
        
        Args:
            user_id: The user identifier.
            
        Returns:
            True if session was cleared, False otherwise.
        """
        # Clear local conversation history
        self.clear_conversation(user_id)
        
        # Clear ADK session if using ADK provider
        if isinstance(self._llm_provider, GoogleADKProvider):
            return await self._llm_provider.forget_session(user_id)
        
        return True

    async def _handle_message(self, incoming: IncomingMessage) -> str:
        """Handle an incoming message from any channel.
        
        Args:
            incoming: The incoming message.
            
        Returns:
            The response string.
        """
        user_id = incoming.user_id
        content = incoming.content.strip()

        # Handle special commands
        if content.lower() == "/clear":
            await self._handle_forget(user_id)
            return "ðŸ—‘ï¸ Conversation cleared. Let's start fresh!"

        if not self._llm_provider:
            return (
                "âš ï¸ LLM provider is not configured. "
                "Please check your configuration."
            )

        try:
            # Use session-based chat for ADK providers
            if isinstance(self._llm_provider, GoogleADKProvider):
                # Set wake-up context before chat
                session_id = await self._llm_provider.get_or_create_session(user_id)
                set_wake_up_context(
                    scheduler=self._scheduler,
                    session_id=session_id,
                    user_id=user_id,
                    channel=incoming.channel,
                    channel_chat_id=incoming.chat_id,
                    username=incoming.username,
                )
                
                # Set instruction context before chat
                set_instruction_context(manager=self._instruction_manager)
                
                # Set tool notification context
                global _tool_notification_context
                _tool_notification_context = {
                    "channel": incoming.channel,
                    "chat_id": incoming.chat_id,
                    "user_id": user_id,
                    "session_id": f"{incoming.channel}:{incoming.chat_id}",
                }
                
                # Set reasoning context with send callback
                async def send_reasoning(content: str, chat_id: str | None) -> None:
                    """Send reasoning message to channel."""
                    if self._channel and chat_id:
                        outgoing = OutgoingMessage(content=content, chat_id=chat_id)
                        await self._channel.send_message(outgoing)
                
                set_reasoning_context(
                    send_callback=send_reasoning,
                    chat_id=incoming.chat_id,
                    channel=incoming.channel,
                )
                
                logger.debug(f"Processing message from {user_id}: {content[:100]}...")
                
                # Prepend message metadata for context
                timestamp = datetime.now().isoformat()
                metadata_prefix = f"[{timestamp}] [{incoming.channel}]"
                if incoming.username:
                    metadata_prefix += f" [@{incoming.username}]"
                enhanced_message = f"{metadata_prefix}\n{content}"
                
                response_content = await self._llm_provider.chat_with_session(
                    user_id=user_id,
                    message=enhanced_message,
                )
                
                # Clear reasoning context after processing
                clear_reasoning_context()
                logger.debug(f"Response generated for {user_id}: {len(response_content)} chars")
                
                return response_content
            
            # Fall back to conversation history for other providers
            logger.debug(f"Using conversation history for provider: {self._llm_provider.name}")
            
            # Get conversation history
            conversation = self._get_or_create_conversation(user_id)
            
            # Add user message
            conversation.append(Message(role="user", content=content))
            
            # Generate response
            response: LLMResponse = await self._llm_provider.chat(
                messages=conversation,
                temperature=0.7,
            )
            
            # Add assistant response to history
            conversation.append(Message(role="assistant", content=response.content))
            
            # Trim conversation if it gets too long (keep system + last 20 messages)
            if len(conversation) > 21:
                self._conversations[user_id] = (
                    [conversation[0]] + conversation[-20:]
                )
            
            return response.content

        except LLMError as e:
            logger.error(f"LLM error for user {user_id}: {e}")
            return f"âŒ Error generating response: {e}"
        except Exception as e:
            logger.exception(f"Unexpected error handling message: {e}")
            return "âŒ An unexpected error occurred. Please try again."

    async def _handle_tool_notification(
        self,
        tool_name: str,
        args: dict,
        result: Any,
    ) -> None:
        """Handle tool call notifications - log to JSON and send simple notification to chat.
        
        Tool call details are logged to JSON file for debugging and analysis.
        Only a simple notification with the tool name is sent to the chat channel
        to avoid cluttering the conversation with verbose tool information.
        
        Args:
            tool_name: Name of the tool being called.
            args: Arguments passed to the tool.
            result: Result of the tool call (None for pre-call).
        
        Generated by Copilot
        """
        global _tool_notification_context
        
        # Get channel info from context
        user_id = _tool_notification_context.get("user_id")
        chat_id = _tool_notification_context.get("chat_id")
        session_id = _tool_notification_context.get("session_id")
        channel = _tool_notification_context.get("channel")
        
        if result is None:
            # Pre-call: Store info for later logging, send simple notification
            _tool_notification_context["pending_tool"] = {
                "tool_name": tool_name,
                "args": args,
                "start_time": datetime.now(),
            }
            
            # Send simple notification to channel
            if chat_id and self._channel:
                try:
                    outgoing = OutgoingMessage(
                        content=f"ðŸ”§ Using: `{tool_name}`",
                        chat_id=chat_id,
                    )
                    await self._channel.send_message(outgoing)
                except Exception as e:
                    logger.warning(f"Failed to send tool notification: {e}")
        else:
            # Post-call: Log complete tool call to JSON
            pending = _tool_notification_context.get("pending_tool", {})
            start_time = pending.get("start_time")
            
            # Calculate duration if we have start time
            duration_ms = None
            if start_time:
                duration_ms = (datetime.now() - start_time).total_seconds() * 1000
            
            # Determine success based on result content
            success = True
            error = None
            if isinstance(result, str):
                if result.startswith("Error:") or result.startswith("âŒ"):
                    success = False
                    error = result
            elif isinstance(result, dict) and result.get("error"):
                success = False
                error = str(result.get("error"))
            
            # Log the complete tool call
            self._tool_logger.log_call(
                tool_name=tool_name,
                args=args,
                result=result,
                success=success,
                error=error,
                duration_ms=duration_ms,
                user_id=user_id,
                session_id=session_id,
                channel=channel,
                chat_id=chat_id,
            )
            
            # Clean up pending tool info
            _tool_notification_context.pop("pending_tool", None)

    async def _initialize_llm(self) -> None:
        """Initialize the LLM provider with tools."""
        try:
            # Collect agent tools
            agent_tools = [
                # Scheduling
                wake_up_in,
                # Instructions
                get_my_instructions,
                update_my_instructions,
                reset_my_instructions,
                # Shell commands
                run_shell_command,
                run_shell_script,
                # File operations
                file_read,
                file_write,
                list_directory,
                delete_file,
                file_info,
                apply_patch,
                # Clone management
                list_clones,
                create_clone,
                start_clone,
                stop_clone,
                delete_clone,
                get_clone_logs,
                # Reasoning
                share_reasoning,
            ]
            
            self._llm_provider = create_llm_provider(
                self.config,
                tools=agent_tools,
            )
            
            # Set up tool call notification callback for ADK provider
            if isinstance(self._llm_provider, GoogleADKProvider):
                self._llm_provider.set_tool_callback(self._handle_tool_notification)
            
            logger.info(
                f"LLM provider initialized: {self._llm_provider.name} "
                f"(model: {self._llm_provider.model}, tools: {len(agent_tools)})"
            )
        except Exception as e:
            logger.error(f"Failed to initialize LLM provider: {e}")
            self._llm_provider = None

    async def _initialize_channel(self) -> None:
        """Initialize the communication channel."""
        try:
            self._channel = create_channel(self.config)
            self._channel.set_message_handler(self._handle_message)
            
            # Set up forget callback for Telegram
            if isinstance(self._channel, TelegramChannel):
                self._channel.set_forget_callback(self._handle_forget)
            
            logger.info(f"Communication channel initialized: {self._channel.name}")
        except Exception as e:
            logger.error(f"Failed to initialize channel: {e}")
            raise

    async def _initialize_api_server(self) -> None:
        """Initialize the HTTP API server for TUI communication."""
        try:
            self._api_server = AgentAPIServer(
                config=self.config,
                message_handler=self._handle_message,
                forget_handler=self._handle_forget,
            )
            logger.info(f"HTTP API server initialized on port {self.config.http_port}")
        except Exception as e:
            logger.error(f"Failed to initialize API server: {e}")
            self._api_server = None

    async def _initialize_webui(self) -> None:
        """Initialize the Web UI server if enabled."""
        if not self.config.web_ui_enabled:
            logger.info("Web UI is disabled in config")
            return
        
        try:
            # Create message handler adapter for WebUI
            async def webui_message_handler(user_id: str, message: str) -> str:
                incoming = IncomingMessage(
                    content=message,
                    user_id=user_id,
                    chat_id=user_id,
                    channel="webui",
                    username=user_id,
                )
                return await self._handle_message(incoming)
            
            self._webui = WebUI(
                config=self.config,
                message_handler=webui_message_handler,
                forget_handler=self._handle_forget,
            )
            logger.info(f"Web UI initialized on port {self.config.web_ui_port}")
        except Exception as e:
            logger.error(f"Failed to initialize Web UI: {e}")
            self._webui = None

    async def _start_webui(self) -> None:
        """Start the Web UI server in the background."""
        if not self._webui:
            return
        
        config = uvicorn.Config(
            app=self._webui.app,
            host="0.0.0.0",
            port=self.config.web_ui_port,
            log_level="warning",
        )
        server = uvicorn.Server(config)
        
        async def run_server():
            await server.serve()
        
        self._webui_server_task = asyncio.create_task(run_server())
        logger.info(f"Web UI server started at http://localhost:{self.config.web_ui_port}")

    async def _process_wakeup(self, wakeup) -> None:
        """Process a scheduled wake-up.
        
        Args:
            wakeup: The ScheduledWakeUp to process.
        """
        logger.info(f"Processing wake-up {wakeup.id} for user {wakeup.user_id}")
        
        if not self._llm_provider or not isinstance(self._llm_provider, GoogleADKProvider):
            logger.warning("Cannot process wake-up: ADK provider not available")
            return
        
        # Build the wake-up message with context
        now = datetime.now()
        wake_up_message = (
            f"[SYSTEM WAKE-UP]\n"
            f"Current time: {now.isoformat()}\n"
            f"You requested to wake up at {wakeup.wake_up_at.isoformat()}\n"
            f"Original request was at {wakeup.scheduled_at.isoformat()}\n"
        )
        if wakeup.reason:
            wake_up_message += f"Reason: {wakeup.reason}\n"
        wake_up_message += "\nPlease continue with the task you scheduled this wake-up for."
        
        try:
            # Set wake-up context
            set_wake_up_context(
                scheduler=self._scheduler,
                session_id=wakeup.session_id,
                user_id=wakeup.user_id,
                channel=wakeup.channel,
                channel_chat_id=wakeup.channel_chat_id,
                username=wakeup.username,
            )
            
            # Get response from agent
            response = await self._llm_provider.chat_with_session(
                user_id=wakeup.user_id,
                message=wake_up_message,
            )
            
            # Send response through appropriate channel
            if self._channel and wakeup.channel_chat_id:
                outgoing = OutgoingMessage(
                    content=response,
                    chat_id=wakeup.channel_chat_id,
                    user_id=wakeup.user_id,
                )
                await self._channel.send_message(outgoing)
                logger.info(f"Sent wake-up response to {wakeup.channel_chat_id}")
            else:
                logger.warning(f"Could not send wake-up response: no channel or chat_id")
            
            # Mark as completed
            self._scheduler.mark_completed(wakeup.id)
            
        except Exception as e:
            logger.error(f"Error processing wake-up {wakeup.id}: {e}")

    async def _wakeup_check_loop(self) -> None:
        """Background loop to check for scheduled wake-ups."""
        logger.info("Starting wake-up check loop")
        
        while self._running:
            try:
                # Reload scheduler data to pick up any changes
                self._scheduler.reload()
                
                # Get due wake-ups
                due_wakeups = self._scheduler.get_due_wakeups()
                
                for wakeup in due_wakeups:
                    await self._process_wakeup(wakeup)
                
                # Check every 30 seconds
                await asyncio.sleep(30)
                
            except asyncio.CancelledError:
                break
            except Exception as e:
                logger.error(f"Error in wake-up check loop: {e}")
                await asyncio.sleep(30)
        
        logger.info("Wake-up check loop stopped")

    async def start(self) -> None:
        """Start the agent."""
        logger.info("Starting Homelab Agent...")
        logger.info(f"LLM Provider: {self.config.llm_provider}")
        logger.info(f"Communication Channel: {self.config.communication_channel}")
        
        self._running = True
        self._shutdown_event = asyncio.Event()
        
        # Initialize LLM provider
        await self._initialize_llm()
        
        # Initialize and start HTTP API server
        await self._initialize_api_server()
        if self._api_server:
            await self._api_server.start()
        
        # Initialize and start Web UI (if enabled)
        await self._initialize_webui()
        if self._webui:
            await self._start_webui()
        
        # Initialize and start communication channel
        await self._initialize_channel()
        
        if self._channel:
            await self._channel.start()
        
        # Start wake-up check loop
        self._wakeup_task = asyncio.create_task(self._wakeup_check_loop())
        
        logger.info("Homelab Agent started successfully.")
        
        # Wait for shutdown signal
        await self._shutdown_event.wait()

    async def stop(self) -> None:
        """Stop the agent gracefully."""
        logger.info("Stopping Homelab Agent...")
        self._running = False
        
        # Cancel wake-up check loop
        if self._wakeup_task:
            self._wakeup_task.cancel()
            try:
                await self._wakeup_task
            except asyncio.CancelledError:
                pass
        
        # Stop Web UI server
        if self._webui_server_task:
            self._webui_server_task.cancel()
            try:
                await self._webui_server_task
            except asyncio.CancelledError:
                pass
        
        # Stop HTTP API server
        if self._api_server:
            await self._api_server.stop()
        
        # Stop communication channel
        if self._channel:
            await self._channel.stop()
        
        if self._shutdown_event:
            self._shutdown_event.set()
        logger.info("Homelab Agent stopped.")

    def handle_signal(self, signum: int, frame: object) -> None:
        """Handle shutdown signals.
        
        Args:
            signum: Signal number.
            frame: Current stack frame.
        """
        logger.info(f"Received signal {signum}, initiating shutdown...")
        if self._shutdown_event:
            self._shutdown_event.set()


async def main() -> None:
    """Main entry point for the agent."""
    try:
        config = Config.load()
    except FileNotFoundError as e:
        logger.error(str(e))
        sys.exit(1)
    
    # Set up file logging for daemon mode
    log_file = config.runtime_dir / "logs" / "agent.log"
    setup_logging(log_file=log_file)
    logger.info(f"Logging to file: {log_file}")
    
    agent = HomelabAgent(config)
    
    # Set up signal handlers
    signal.signal(signal.SIGTERM, agent.handle_signal)
    signal.signal(signal.SIGINT, agent.handle_signal)
    
    try:
        await agent.start()
    except Exception as e:
        logger.exception(f"Agent error: {e}")
        sys.exit(1)
    finally:
        await agent.stop()


if __name__ == "__main__":
    asyncio.run(main())
