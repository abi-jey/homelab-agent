"""Telegram communication channel implementation."""

import asyncio
import logging
import tempfile
from dataclasses import dataclass
from datetime import datetime
from pathlib import Path
from typing import Callable, Optional, Awaitable

from telegram import Update
from telegram.ext import (
    Application,
    CommandHandler as TelegramCommandHandler,
    ContextTypes,
    MessageHandler as TelegramMessageHandler,
    filters,
)

from homelab_agent.channels.base import (
    BaseCommunicationChannel,
    ChannelConfigurationError,
    ChannelError,
    IncomingMessage,
    MessageHandler,
    MessagePart,
    OutgoingMessage,
)
from homelab_agent.config import Config
from homelab_agent.services.transcription import TranscriptionService

logger = logging.getLogger(__name__)

# Type for forget session callback
ForgetSessionCallback = Callable[[str], Awaitable[bool]]

# Message bundling delay in seconds (wait this long to collect related messages)
MESSAGE_BUNDLE_DELAY = 2.0


@dataclass
class PendingMessage:
    """A pending message waiting to be bundled.
    
    Generated by Copilot
    """
    user_id: str
    username: Optional[str]
    content: str
    chat_id: int
    telegram_user_id: str
    message_id: int
    timestamp: datetime
    update: Update


class TelegramChannel(BaseCommunicationChannel):
    """Telegram communication channel.
    
    Uses the python-telegram-bot library to interact with users
    via a Telegram bot.
    """

    def __init__(self, config: Config) -> None:
        """Initialize the Telegram channel.
        
        Args:
            config: The agent configuration.
            
        Raises:
            ChannelConfigurationError: If bot token is not configured.
        """
        if not config.telegram_bot_token:
            raise ChannelConfigurationError(
                "Telegram bot token is required. "
                "Set it in the configuration."
            )

        self._config = config
        self._application: Optional[Application] = None
        self._message_handler: Optional[MessageHandler] = None
        self._forget_callback: Optional[ForgetSessionCallback] = None
        self._is_running = False
        self._allowed_users: set[str] = set()
        self._user_chat_ids: dict[str, int] = {}  # Map user_id to chat_id
        
        # Initialize transcription service if STT is enabled
        self._transcription_service: Optional[TranscriptionService] = None
        if config.stt_enabled and config.google_api_key:
            self._transcription_service = TranscriptionService(
                api_key=config.google_api_key,
                model=config.stt_model,
            )
            logger.info(f"Transcription service initialized with model {config.stt_model}")
        
        # Initialize image analysis service
        from homelab_agent.services.image_analysis import ImageAnalysisService
        self._image_service: Optional[ImageAnalysisService] = None
        if config.google_api_key:
            self._image_service = ImageAnalysisService(
                api_key=config.google_api_key,
                model=config.stt_model,  # Use same model for vision
            )
            logger.info("Image analysis service initialized")

        # Parse allowed users (already a list in config)
        if config.telegram_allowed_users:
            self._allowed_users = {
                u.strip() if isinstance(u, str) else str(u)
                for u in config.telegram_allowed_users
                if u
            }
        
        # Message bundling state (per chat)
        # Generated by Copilot
        self._pending_messages: dict[str, list[PendingMessage]] = {}
        self._bundle_tasks: dict[str, asyncio.Task] = {}
        self._bundle_locks: dict[str, asyncio.Lock] = {}

    @property
    def name(self) -> str:
        """Get the channel name."""
        return "telegram"

    @property
    def is_running(self) -> bool:
        """Check if the channel is running."""
        return self._is_running

    def set_message_handler(self, handler: MessageHandler) -> None:
        """Set the handler for incoming messages."""
        self._message_handler = handler

    def set_forget_callback(self, callback: ForgetSessionCallback) -> None:
        """Set the callback for forgetting sessions.
        
        Args:
            callback: Async function that takes user_id and returns True if successful.
        """
        self._forget_callback = callback

    def _is_user_allowed(self, user_id: str, username: Optional[str]) -> bool:
        """Check if a user is allowed to interact with the bot."""
        if not self._allowed_users:
            return True

        if str(user_id) in self._allowed_users:
            return True
        if username and username in self._allowed_users:
            return True
        if username and f"@{username}" in self._allowed_users:
            return True

        return False

    def _get_session_user_id(self, telegram_user_id: str, username: Optional[str]) -> str:
        """Get a consistent user identifier for sessions.
        
        Prefers username (more readable) but falls back to numeric ID.
        
        Args:
            telegram_user_id: The numeric Telegram user ID.
            username: The Telegram username (may be None).
            
        Returns:
            A consistent user identifier string.
        """
        if username:
            return f"@{username}"
        return telegram_user_id

    async def _handle_start(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE
    ) -> None:
        """Handle the /start command."""
        if not update.effective_user or not update.message:
            return

        user_id = str(update.effective_user.id)
        username = update.effective_user.username

        if not self._is_user_allowed(user_id, username):
            await update.message.reply_text(
                "â›” Sorry, you are not authorized to use this bot."
            )
            logger.warning(
                f"Unauthorized access attempt from user {user_id} (@{username})"
            )
            return

        # Get session user ID and store chat_id
        session_user_id = self._get_session_user_id(user_id, username)
        self._user_chat_ids[session_user_id] = update.message.chat_id

        await update.message.reply_text(
            "ðŸ  *Homelab Agent*\n\n"
            "I'm your homelab assistant. Send me a message and I'll help you "
            "manage your homelab!\n\n"
            "Commands:\n"
            "/start - Show this message\n"
            "/status - Check agent status\n"
            "/forget - Start a new conversation\n"
            "/help - Get help",
            parse_mode="Markdown",
        )

    async def _handle_forget(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE
    ) -> None:
        """Handle the /forget command - clears session history."""
        if not update.effective_user or not update.message:
            return

        user_id = str(update.effective_user.id)
        username = update.effective_user.username

        if not self._is_user_allowed(user_id, username):
            return

        # Use session user ID for forget
        session_user_id = self._get_session_user_id(user_id, username)

        if self._forget_callback:
            try:
                success = await self._forget_callback(session_user_id)
                if success:
                    await update.message.reply_text(
                        "ðŸ—‘ï¸ Memory cleared! Starting fresh conversation."
                    )
                else:
                    await update.message.reply_text(
                        "â„¹ï¸ No previous conversation found."
                    )
            except Exception as e:
                logger.error(f"Error in forget callback: {e}")
                await update.message.reply_text(
                    "âŒ Failed to clear conversation. Please try again."
                )
        else:
            await update.message.reply_text(
                "â„¹ï¸ Session management not available."
            )

    async def _handle_status(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE
    ) -> None:
        """Handle the /status command."""
        if not update.effective_user or not update.message:
            return

        user_id = str(update.effective_user.id)
        username = update.effective_user.username

        if not self._is_user_allowed(user_id, username):
            return

        await update.message.reply_text(
            "âœ… *Agent Status*\n\n"
            f"ðŸ”§ LLM Provider: `{self._config.llm_provider}`\n"
            f"ðŸ“¡ Channel: `{self._config.communication_channel}`\n"
            f"ðŸ“‚ Runtime: `{self._config.runtime_dir}`",
            parse_mode="Markdown",
        )

    async def _handle_help(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE
    ) -> None:
        """Handle the /help command."""
        if not update.effective_user or not update.message:
            return

        user_id = str(update.effective_user.id)
        username = update.effective_user.username

        if not self._is_user_allowed(user_id, username):
            return

        await update.message.reply_text(
            "ðŸ“š *Help*\n\n"
            "Send me any message and I'll process it using the configured LLM.\n\n"
            "You can ask me to:\n"
            "â€¢ Check system status\n"
            "â€¢ Run commands\n"
            "â€¢ Manage services\n"
            "â€¢ And more!\n\n"
            "Just describe what you need in plain language.",
            parse_mode="Markdown",
        )

    def _get_bundle_lock(self, chat_id: str) -> asyncio.Lock:
        """Get or create a lock for message bundling for a chat.
        
        Generated by Copilot
        """
        if chat_id not in self._bundle_locks:
            self._bundle_locks[chat_id] = asyncio.Lock()
        return self._bundle_locks[chat_id]

    async def _process_bundled_messages(self, chat_id: str) -> None:
        """Process bundled messages for a chat after the delay.
        
        This method is called after MESSAGE_BUNDLE_DELAY seconds to process
        all pending messages for a chat as a single bundled message.
        
        Args:
            chat_id: The chat ID to process messages for.
        
        Generated by Copilot
        """
        lock = self._get_bundle_lock(chat_id)
        async with lock:
            # Get pending messages for this chat
            pending = self._pending_messages.pop(chat_id, [])
            if chat_id in self._bundle_tasks:
                del self._bundle_tasks[chat_id]
            
            if not pending:
                return
            
            if not self._message_handler:
                # Send error to first message
                if pending[0].update.message:
                    await pending[0].update.message.reply_text(
                        "âš ï¸ No message handler configured. Please contact the administrator."
                    )
                return
            
            try:
                # Get first message for user info
                first_msg = pending[0]
                
                if len(pending) == 1:
                    # Single message - no bundling needed
                    incoming = IncomingMessage(
                        channel=self.name,
                        user_id=first_msg.user_id,
                        username=first_msg.username,
                        content=first_msg.content,
                        chat_id=str(first_msg.chat_id),
                        raw_data={
                            "chat_id": first_msg.chat_id,
                            "message_id": first_msg.message_id,
                            "telegram_user_id": first_msg.telegram_user_id,
                        },
                    )
                else:
                    # Multiple messages - create bundled message
                    logger.info(f"Bundling {len(pending)} messages from chat {chat_id}")
                    
                    # Create message parts
                    parts = [
                        MessagePart(
                            content=msg.content,
                            sender=msg.username,
                            timestamp=msg.timestamp,
                        )
                        for msg in pending
                    ]
                    
                    # Combine content for the main content field
                    combined_content = "\n".join(msg.content for msg in pending)
                    
                    incoming = IncomingMessage(
                        channel=self.name,
                        user_id=first_msg.user_id,
                        username=first_msg.username,
                        content=combined_content,
                        chat_id=str(first_msg.chat_id),
                        raw_data={
                            "chat_id": first_msg.chat_id,
                            "message_count": len(pending),
                            "telegram_user_id": first_msg.telegram_user_id,
                        },
                        bundled_messages=parts,
                        is_bundled=True,
                    )
                
                # Process the message
                response = await self._message_handler(incoming)
                
                # Reply to the last message in the bundle
                last_update = pending[-1].update
                if last_update.message:
                    await last_update.message.reply_text(response)
                    
            except Exception as e:
                logger.error(f"Error processing bundled messages: {e}")
                last_update = pending[-1].update
                if last_update.message:
                    await last_update.message.reply_text(
                        "âŒ Sorry, I encountered an error processing your message. "
                        "Please try again later."
                    )

    async def _handle_message(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE
    ) -> None:
        """Handle incoming text messages with bundling support.
        
        Messages from the same chat are bundled together if they arrive
        within MESSAGE_BUNDLE_DELAY seconds of each other. This allows
        users to send multiple messages that are processed as one request.
        
        Generated by Copilot
        """
        if not update.effective_user or not update.message or not update.message.text:
            return

        user_id = str(update.effective_user.id)
        username = update.effective_user.username
        message_text = update.message.text
        chat_id = str(update.message.chat_id)

        if not self._is_user_allowed(user_id, username):
            await update.message.reply_text(
                "â›” Sorry, you are not authorized to use this bot."
            )
            return

        # Get session user ID (prefers username)
        session_user_id = self._get_session_user_id(user_id, username)

        # Store chat_id for later use (use session_user_id as key)
        self._user_chat_ids[session_user_id] = update.message.chat_id

        logger.info(f"Message from {session_user_id}: {message_text[:50]}...")

        # Show typing indicator
        await update.message.chat.send_action("typing")

        if not self._message_handler:
            await update.message.reply_text(
                "âš ï¸ No message handler configured. Please contact the administrator."
            )
            return

        # Create pending message
        pending_msg = PendingMessage(
            user_id=session_user_id,
            username=username,
            content=message_text,
            chat_id=update.message.chat_id,
            telegram_user_id=user_id,
            message_id=update.message.message_id,
            timestamp=datetime.now(),
            update=update,
        )
        
        # Add to pending messages for this chat
        lock = self._get_bundle_lock(chat_id)
        async with lock:
            if chat_id not in self._pending_messages:
                self._pending_messages[chat_id] = []
            self._pending_messages[chat_id].append(pending_msg)
            
            # Cancel existing timer if any
            if chat_id in self._bundle_tasks:
                self._bundle_tasks[chat_id].cancel()
            
            # Start new timer
            self._bundle_tasks[chat_id] = asyncio.create_task(
                self._delayed_process(chat_id)
            )

    async def _delayed_process(self, chat_id: str) -> None:
        """Wait for bundle delay then process messages.
        
        Generated by Copilot
        """
        try:
            await asyncio.sleep(MESSAGE_BUNDLE_DELAY)
            await self._process_bundled_messages(chat_id)
        except asyncio.CancelledError:
            # Timer was cancelled, new message arrived
            pass

    async def _handle_voice(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE
    ) -> None:
        """Handle incoming voice messages with transcription."""
        if not update.effective_user or not update.message:
            return

        user_id = str(update.effective_user.id)
        username = update.effective_user.username

        if not self._is_user_allowed(user_id, username):
            await update.message.reply_text(
                "â›” Sorry, you are not authorized to use this bot."
            )
            return

        # Get session user ID
        session_user_id = self._get_session_user_id(user_id, username)
        self._user_chat_ids[session_user_id] = update.message.chat_id

        voice = update.message.voice
        if not voice:
            return
            
        duration = voice.duration

        logger.info(f"Voice message from {session_user_id}: {duration}s")
        
        # Show typing indicator
        await update.message.chat.send_action("typing")
        
        # Check if transcription is available
        if not self._transcription_service:
            await update.message.reply_text(
                f"ðŸŽ¤ *Voice message received!* ({duration}s)\n\n"
                "Speech-to-text is not enabled. Please send text messages.",
                parse_mode="Markdown",
            )
            return
        
        try:
            # Download the voice file
            voice_file = await voice.get_file()
            
            # Download to bytes
            voice_bytes = await voice_file.download_as_bytearray()
            
            # Transcribe the audio (Telegram sends OGG/Opus)
            result = await self._transcription_service.transcribe_bytes(
                bytes(voice_bytes),
                mime_type="audio/ogg",
            )
            
            if not result.success:
                await update.message.reply_text(
                    f"ðŸŽ¤ *Voice message received!* ({duration}s)\n\n"
                    f"âŒ Could not transcribe: {result.error}",
                    parse_mode="Markdown",
                )
                return
            
            transcribed_text = result.text
            
            # Log the transcription
            logger.info(f"Transcribed from {session_user_id}: {transcribed_text[:100]}...")
            
            # Show the transcription to user
            await update.message.reply_text(
                f"ðŸŽ¤ *Transcribed:*\n_{transcribed_text}_",
                parse_mode="Markdown",
            )
            
            # Process through message handler as if it was text
            if self._message_handler:
                incoming = IncomingMessage(
                    channel=self.name,
                    user_id=session_user_id,
                    username=username,
                    content=transcribed_text,
                    chat_id=str(update.message.chat_id),
                    raw_data={
                        "chat_id": update.message.chat_id,
                        "message_id": update.message.message_id,
                        "telegram_user_id": user_id,
                        "voice_duration": duration,
                        "transcribed": True,
                    },
                )
                
                await update.message.chat.send_action("typing")
                response = await self._message_handler(incoming)
                await update.message.reply_text(response)
                
        except Exception as e:
            logger.error(f"Error processing voice message: {e}")
            await update.message.reply_text(
                "âŒ Sorry, I couldn't process your voice message. Please try again.",
            )

    async def _handle_audio(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE
    ) -> None:
        """Handle incoming audio files (music, podcasts, etc.)."""
        if not update.effective_user or not update.message:
            return

        user_id = str(update.effective_user.id)
        username = update.effective_user.username

        if not self._is_user_allowed(user_id, username):
            await update.message.reply_text(
                "â›” Sorry, you are not authorized to use this bot."
            )
            return

        session_user_id = self._get_session_user_id(user_id, username)
        self._user_chat_ids[session_user_id] = update.message.chat_id

        audio = update.message.audio
        if not audio:
            return

        duration = audio.duration or 0
        title = audio.title or "Unknown"
        performer = audio.performer or "Unknown"

        logger.info(f"Audio file from {session_user_id}: {title} by {performer} ({duration}s)")

        await update.message.reply_text(
            f"ðŸŽµ *Audio file received!*\n\n"
            f"Title: {title}\n"
            f"Artist: {performer}\n"
            f"Duration: {duration}s\n\n"
            "Audio file analysis coming soon.",
            parse_mode="Markdown",
        )

    async def _handle_photo(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE
    ) -> None:
        """Handle incoming photos with image analysis."""
        if not update.effective_user or not update.message:
            return

        user_id = str(update.effective_user.id)
        username = update.effective_user.username

        if not self._is_user_allowed(user_id, username):
            await update.message.reply_text(
                "â›” Sorry, you are not authorized to use this bot."
            )
            return

        session_user_id = self._get_session_user_id(user_id, username)
        self._user_chat_ids[session_user_id] = update.message.chat_id

        photos = update.message.photo
        if not photos:
            return
        
        # Get the largest photo
        photo = photos[-1]
        caption = update.message.caption or ""

        logger.info(f"Photo from {session_user_id}: {photo.width}x{photo.height}, caption: {caption[:50] if caption else 'none'}")

        # Check if image analysis is available
        if not self._image_service:
            await update.message.reply_text(
                f"ðŸ“¸ *Photo received!* ({photo.width}x{photo.height})\n\n"
                f"{f'Caption: {caption}' if caption else 'No caption'}\n\n"
                "âš ï¸ Image analysis is not configured.",
                parse_mode="Markdown",
            )
            return

        # Show typing indicator
        await update.message.chat.send_action("typing")

        try:
            # Download the photo
            photo_file = await photo.get_file()
            photo_bytes = await photo_file.download_as_bytearray()
            
            # Analyze the image
            result = await self._image_service.analyze_bytes(
                data=bytes(photo_bytes),
                mime_type="image/jpeg",
                caption=caption,
            )
            
            if result.success:
                # Send the analysis to the agent
                message_content = f"[Image received: {photo.width}x{photo.height}]"
                if caption:
                    message_content += f"\nCaption: {caption}"
                message_content += f"\n\nImage analysis: {result.description}"
                
                if self._message_handler:
                    incoming = IncomingMessage(
                        channel=self.name,
                        user_id=session_user_id,
                        username=username,
                        content=message_content,
                        chat_id=str(update.message.chat_id),
                        raw_data={
                            "type": "photo",
                            "width": photo.width,
                            "height": photo.height,
                            "caption": caption,
                        },
                    )
                    response = await self._message_handler(incoming)
                    await update.message.reply_text(response)
                else:
                    # Just send the analysis if no message handler
                    await update.message.reply_text(
                        f"ðŸ“¸ *Image Analysis*\n\n{result.description}",
                        parse_mode="Markdown",
                    )
            else:
                await update.message.reply_text(
                    f"ðŸ“¸ Photo received but analysis failed: {result.error}",
                )
                
        except Exception as e:
            logger.exception(f"Error analyzing photo: {e}")
            await update.message.reply_text(
                f"ðŸ“¸ Photo received but I couldn't analyze it: {e}"
            )

    async def _handle_video(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE
    ) -> None:
        """Handle incoming videos."""
        if not update.effective_user or not update.message:
            return

        user_id = str(update.effective_user.id)
        username = update.effective_user.username

        if not self._is_user_allowed(user_id, username):
            await update.message.reply_text(
                "â›” Sorry, you are not authorized to use this bot."
            )
            return

        session_user_id = self._get_session_user_id(user_id, username)
        self._user_chat_ids[session_user_id] = update.message.chat_id

        video = update.message.video
        if not video:
            return

        duration = video.duration or 0
        caption = update.message.caption or ""

        logger.info(f"Video from {session_user_id}: {video.width}x{video.height}, {duration}s")

        await update.message.reply_text(
            f"ðŸŽ¬ *Video received!* ({video.width}x{video.height}, {duration}s)\n\n"
            f"{f'Caption: {caption}' if caption else 'No caption'}\n\n"
            "Video analysis coming soon.",
            parse_mode="Markdown",
        )

    async def _handle_video_note(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE
    ) -> None:
        """Handle incoming video notes (circular videos)."""
        if not update.effective_user or not update.message:
            return

        user_id = str(update.effective_user.id)
        username = update.effective_user.username

        if not self._is_user_allowed(user_id, username):
            await update.message.reply_text(
                "â›” Sorry, you are not authorized to use this bot."
            )
            return

        session_user_id = self._get_session_user_id(user_id, username)
        self._user_chat_ids[session_user_id] = update.message.chat_id

        video_note = update.message.video_note
        if not video_note:
            return

        duration = video_note.duration or 0

        logger.info(f"Video note from {session_user_id}: {duration}s")

        await update.message.reply_text(
            f"â­• *Video note received!* ({duration}s)\n\n"
            "Video note analysis coming soon.",
            parse_mode="Markdown",
        )

    async def _handle_document(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE
    ) -> None:
        """Handle incoming documents/files."""
        if not update.effective_user or not update.message:
            return

        user_id = str(update.effective_user.id)
        username = update.effective_user.username

        if not self._is_user_allowed(user_id, username):
            await update.message.reply_text(
                "â›” Sorry, you are not authorized to use this bot."
            )
            return

        session_user_id = self._get_session_user_id(user_id, username)
        self._user_chat_ids[session_user_id] = update.message.chat_id

        document = update.message.document
        if not document:
            return

        file_name = document.file_name or "Unknown"
        file_size = document.file_size or 0
        mime_type = document.mime_type or "unknown"
        caption = update.message.caption or ""

        # Format file size
        if file_size < 1024:
            size_str = f"{file_size} B"
        elif file_size < 1024 * 1024:
            size_str = f"{file_size / 1024:.1f} KB"
        else:
            size_str = f"{file_size / (1024 * 1024):.1f} MB"

        logger.info(f"Document from {session_user_id}: {file_name} ({size_str})")

        await update.message.reply_text(
            f"ðŸ“„ *Document received!*\n\n"
            f"Name: `{file_name}`\n"
            f"Size: {size_str}\n"
            f"Type: {mime_type}\n"
            f"{f'Caption: {caption}' if caption else ''}\n\n"
            "Document processing coming soon.",
            parse_mode="Markdown",
        )

    async def _handle_location(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE
    ) -> None:
        """Handle incoming location shares."""
        if not update.effective_user or not update.message:
            return

        user_id = str(update.effective_user.id)
        username = update.effective_user.username

        if not self._is_user_allowed(user_id, username):
            await update.message.reply_text(
                "â›” Sorry, you are not authorized to use this bot."
            )
            return

        session_user_id = self._get_session_user_id(user_id, username)
        self._user_chat_ids[session_user_id] = update.message.chat_id

        location = update.message.location
        if not location:
            return

        logger.info(f"Location from {session_user_id}: {location.latitude}, {location.longitude}")

        await update.message.reply_text(
            f"ðŸ“ *Location received!*\n\n"
            f"Latitude: `{location.latitude}`\n"
            f"Longitude: `{location.longitude}`\n\n"
            "Location-based features coming soon.",
            parse_mode="Markdown",
        )

    async def _handle_sticker(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE
    ) -> None:
        """Handle incoming stickers."""
        if not update.effective_user or not update.message:
            return

        user_id = str(update.effective_user.id)
        username = update.effective_user.username

        if not self._is_user_allowed(user_id, username):
            return  # Silently ignore stickers from unauthorized users

        session_user_id = self._get_session_user_id(user_id, username)
        self._user_chat_ids[session_user_id] = update.message.chat_id

        sticker = update.message.sticker
        if not sticker:
            return

        emoji = sticker.emoji or "ðŸŽ¨"
        is_animated = sticker.is_animated
        is_video = sticker.is_video

        logger.info(f"Sticker from {session_user_id}: {emoji} (animated={is_animated}, video={is_video})")

        # For static stickers, we can analyze them
        if not is_animated and not is_video and self._image_service:
            try:
                # Download the sticker
                sticker_file = await sticker.get_file()
                sticker_bytes = await sticker_file.download_as_bytearray()
                
                # Determine MIME type
                mime_type = "image/webp"  # Telegram stickers are typically WebP
                
                # Analyze the sticker
                result = await self._image_service.analyze_sticker(
                    data=bytes(sticker_bytes),
                    mime_type=mime_type,
                    emoji=emoji,
                )
                
                if result.success:
                    # Send to agent with sticker context
                    message_content = f"[Sticker received: {emoji}]\n\nSticker description: {result.description}"
                    
                    if self._message_handler:
                        incoming = IncomingMessage(
                            channel=self.name,
                            user_id=session_user_id,
                            username=username,
                            content=message_content,
                            chat_id=str(update.message.chat_id),
                            raw_data={
                                "type": "sticker",
                                "emoji": emoji,
                            },
                        )
                        response = await self._message_handler(incoming)
                        await update.message.reply_text(response)
                        return
                    else:
                        # Just describe the sticker
                        await update.message.reply_text(
                            f"{emoji} *Sticker:* {result.description}",
                            parse_mode="Markdown",
                        )
                        return
            except Exception as e:
                logger.debug(f"Could not analyze sticker: {e}")
        
        # Fallback: just acknowledge with emoji
        await update.message.reply_text(f"{emoji} Nice sticker!")

    def _build_application(self) -> Application:
        """Build and configure the Telegram application."""
        if not self._config.telegram_bot_token:
            raise ChannelConfigurationError("Telegram bot token is not configured")
        
        self._application = (
            Application.builder()
            .token(self._config.telegram_bot_token)
            .build()
        )

        # Add command handlers
        self._application.add_handler(
            TelegramCommandHandler("start", self._handle_start)
        )
        self._application.add_handler(
            TelegramCommandHandler("status", self._handle_status)
        )
        self._application.add_handler(
            TelegramCommandHandler("help", self._handle_help)
        )
        self._application.add_handler(
            TelegramCommandHandler("forget", self._handle_forget)
        )
        
        # Add message type handlers
        self._application.add_handler(
            TelegramMessageHandler(
                filters.TEXT & ~filters.COMMAND, self._handle_message
            )
        )
        self._application.add_handler(
            TelegramMessageHandler(
                filters.VOICE, self._handle_voice
            )
        )
        self._application.add_handler(
            TelegramMessageHandler(
                filters.AUDIO, self._handle_audio
            )
        )
        self._application.add_handler(
            TelegramMessageHandler(
                filters.PHOTO, self._handle_photo
            )
        )
        self._application.add_handler(
            TelegramMessageHandler(
                filters.VIDEO, self._handle_video
            )
        )
        self._application.add_handler(
            TelegramMessageHandler(
                filters.VIDEO_NOTE, self._handle_video_note
            )
        )
        self._application.add_handler(
            TelegramMessageHandler(
                filters.Document.ALL, self._handle_document
            )
        )
        self._application.add_handler(
            TelegramMessageHandler(
                filters.LOCATION, self._handle_location
            )
        )
        self._application.add_handler(
            TelegramMessageHandler(
                filters.Sticker.ALL, self._handle_sticker
            )
        )

        return self._application

    async def start(self) -> None:
        """Start the Telegram channel."""
        if self._is_running:
            logger.warning("Telegram channel is already running")
            return

        try:
            if not self._application:
                self._build_application()

            if not self._application:
                raise ChannelError("Failed to build Telegram application")

            logger.info("Starting Telegram channel...")
            await self._application.initialize()
            await self._application.start()
            if self._application.updater:
                await self._application.updater.start_polling(drop_pending_updates=True)
            self._is_running = True
            logger.info("Telegram channel started successfully")

        except Exception as e:
            logger.exception(f"Failed to start Telegram channel: {e}")
            raise ChannelError(f"Failed to start Telegram channel: {e}")

    async def stop(self) -> None:
        """Stop the Telegram channel."""
        if not self._is_running or not self._application:
            return

        try:
            logger.info("Stopping Telegram channel...")
            if self._application.updater:
                await self._application.updater.stop()
            await self._application.stop()
            await self._application.shutdown()
            self._is_running = False
            logger.info("Telegram channel stopped")

        except Exception as e:
            logger.exception(f"Error stopping Telegram channel: {e}")

    async def send_message(self, message: OutgoingMessage) -> bool:
        """Send a message through Telegram."""
        if not self._application or not self._is_running:
            logger.warning("Cannot send message: Telegram channel is not running")
            return False

        # Use chat_id from message if provided, otherwise look up by user_id
        chat_id = None
        if message.chat_id:
            chat_id = int(message.chat_id)
        elif message.user_id:
            chat_id = self._user_chat_ids.get(message.user_id)
        
        if not chat_id:
            logger.warning(f"Cannot send message: No chat_id available")
            return False

        try:
            await self._application.bot.send_message(
                chat_id=chat_id,
                text=message.content,
                parse_mode=message.parse_mode,
            )
            return True

        except Exception as e:
            logger.error(f"Failed to send Telegram message: {e}")
            return False
